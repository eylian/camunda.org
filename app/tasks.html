<!DOCTYPE html>
<html lang="en">
  <head>
    <title>camunda.org - the camunda bpm community homepage</title>
    
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <meta name="author" content="camunda.org community" />
        
    <!-- loads all stylesheets -->
    <link href="assets/css/loader.css" rel="stylesheet" />
	  
	<!--
	<script src="assets/js/lib/jquery-1.7.2.min.js"></script> 
	<script src="assets/js/lib/bootstrap/bootstrap.min.js"></script> 	
	<script src="assets/js/lib/raphaeljs/raphael.js"></script> 
	<script src="assets/js/app/cabpmn.js"></script> 
	-->
    <!-- For IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
     
    <base app-base="." />

  </head>
  <body ng-controller="DefaultController" >
    <div class="wrapper">
      <!-- navigation -->
      <div data-ng-include=" 'templates/navigation.html' "></div>

<header class="hero-unit" id="overview">
  <div class="center">
    <h1>Tasks, Gateways & Lanes</h1>
    <h2>BPMN 2.0 Tutorial</h2>
	</div>
</header>

<div class="container" >
	<!--<div tutorial="partials/design/tutorial.md" />-->
	<div class="row">
  
      <div id="navSide" class="span3 bs-docs-sidebar"  >
        <ul class="nav nav-list bs-docs-sidenav" data-ca-affix>
		  <li ><a href="#taskTypesSect"><i class="icon-chevron-right"></i> Task Types</a></li>
		  <li ><a href="#taskMarkersSect"><i class="icon-chevron-right"></i> Task Markers</a></li>
		  <li ><a href="#exclusiveSect"><i class="icon-chevron-right"></i> Exclusive Gateways</a></li>
          <li><a href="#parallelSect"><i class="icon-chevron-right"></i> Parallel Gateways</a></li>
		  <li><a href="#inclusiveSect"><i class="icon-chevron-right"></i> Inclusive Gateways</a></li>
		  <li><a href="#eventSect"><i class="icon-chevron-right"></i> Event-based Gateways</a></li>		   		  
		  <li><a href="#lanesSect"><i class="icon-chevron-right"></i> Lanes</a></li>		   		  		  
		</ul>
      </div>

	  
     <div id="content" class="span9"  data-bpmn-tutorial>
		<section id="taskTypesSect">
			<div class="page-header" >
				<h1>Task Types</h1>
			</div>
			<p>
				So far, we have used only tasks of undefined types, though BPMN provides the opportunity to work with task types just as it does for event types. Primarily, task types are intended to model processes 
				that are technically executable. Task types are applied infrequently in practice. We know from experience, however, that task types can be particularly useful when modeling engineering requirements. 
			</p>
			<div class="label label-warning">Hover over orange symbols for explanation</div>
			<div id="task_types" style="position:relative" data-bpmn-src="tutorial/task_types">

				<div class="tutPop" id="sid-1077EBAA-70D6-47EE-9510-DF4479FAD35F" rel="popover" title="Manual Task" data-content="
					Tasks executed by a human being that do not affect the completion of a task assigned by the process engine. All the tasks from our various pizza processes are manual types.
					Other examples: File a document in a folder; Clarify an incorrect invoice by phone; Talk with customers at the counter.
				">
				</div>
				<div class="tutPop" id="sid-3A1B9DDB-E7D7-451A-A22A-4EA9DFF362E0" rel="popover" title="User Task" data-content="
					User tasks are executed by people just like the manual tasks, but they are assigned by a process engine, which may, for example, place these tasks in each user's task list.
					After the human finishes a task, the engine expects confirmation, usually including data input or a button click. User tasks are part of the Human Workflow Management. 
					Typical task examples from the world of Human Workflow Management are: 
					Check an invoice; Approve an application for vacation; Process a support request.
				">
				</div>
				<div class="tutPop" id="sid-78961443-B838-4FCF-B866-47B5C02AF1CF" rel="popover" title="Receive Task" data-content="
					Receiving a message can be modeled as a separate task. This task type is an alternative to the catching message event, which is why the symbol for the event defined in BPMN 2.0 is an empty envelope.
				">
				</div>
				<div class="tutPop" id="sid-4D496B82-8352-4988-BAC7-D1EBD31E9686" rel="popover" title="Receive Task (instantiating)" data-content="
					If a receive task is to instantiate a process, that is, the receive tasks replaces the message start event, this is shown by a small event symbol in the top left corner.
				">
				</div>
				<div class="tutPop" id="sid-560C2BF6-8B1C-44F4-8C10-0295C94BB023" rel="popover" title="Send Task" data-content="
					These tasks are technical, and the process engine executes them. Therefore, they mainly are used for calling web services asynchronously through message queues.
				">
				</div>
				<div class="tutPop" id="sid-84857C66-6D20-422B-8FBE-827ED409BACD" rel="popover" title="Script Task" data-content="
					Scripts execute directly in the process engine, so they must be written in a language that the process engine can interpret. 
				">
				</div>
				<div class="tutPop" id="sid-49FD21F7-CB64-40E5-9C04-EA23714A3A20" rel="popover" title="Service Task" data-content="
					Service tasks are those done by software. These are program functions applied automatically as a process executes. BPMN normally assumes that this function is provided as web service, 
					though it can be another implementation. The service task is a component of process-oriented implementation integration, which explains why it is so similar in concept to Service-Oriented 
					Architecture (SOA). Typical examples from the world of implementation integration are: The credit rating provided by a rating agency, obtained as XML through HTTP during a credit check; 
					Booking an invoice received as EDIFACT through X.400 in SAP R/3; 
					The offer of substandard goods by an online auction house, as a web service.	
				">
				</div>
				<div class="tutPop" id="sid-57BFD335-5F96-4C21-858E-81E4D52510EB" rel="popover" title="Business Rule Task" data-content="
					BPMN 2.0 provides another task type: the business rule. This task type is used solely to apply business rules. 
				">
				</div>
			</div>
		</section>
		<section id="taskMarkersSect">
			<div class="page-header" >
				<h1>Task Markers</h1>
			</div>
			In addition to those various types of tasks, we can mark tasks as loops, multiple instances, or compensations. Markers can be combined with the assigned types. 			
			<h2>Loop</h2>
			<p>
				A loop task repeats until a defined condition either applies or ceases to apply. Perhaps we suggest various dishes to our dinner guests until everyone agrees. Then, we can prepare the meal:
			</p>
			<div id="task_loop" style="position:relative" data-bpmn-src="tutorial/task_loop">
			</div>
			<p>
				In the example, we executed the task first and checked afterwards to see if we needed it to execute again. Programmers know the principle as the "do-while" construct. 
				We can also apply a "while-do" construct, however, and so check for a condition before the task instead of afterward. This occurs rarely, but it makes sense if the task may not execute at all. 
			</p>
			<p>
				You can attach the condition on which a loop task executes for the first time or, as shown in the example, apply the condition on repeated executions as an annotation to the task. 
				You can store this condition as an attribute in a formal language of your BPMN tool as well. That makes sense if the process is to be executed by a process engine.  			
			</p>
			<h2>Multiple Instance</h2>
			<p>
				The individual cycles of a loop task must follow each other. If for example we live in a flat-sharing community and the roommates feel like eating pizza, the "choose pizza" task must be 
				repeated for each roommate before we can order. You'd sit together and pass a menu around until finally everyone has made a decision. There are student apartments 
				where they <b>do</b> handle it like that - more evidence that students have too much time on their hands! It is much more efficient for all roommates to look at the menu at once, and 
				they choose a pizza together. You can model this process using the "multiple task" (see below). 
				A multiple task instantiates repeatedly and can be executed in sequence or in parallel, with the latter being the more interesting case.
			</p>
			<div id="task_mi" style="position:relative" data-bpmn-src="tutorial/task_mi">
			</div>
		
			<p>
				Do you think the example is absurd? How does your company check invoices for group orders, such as for office supplies? Do you forward the invoice from one employee to the next, so that each 
				person can sign off on the items he or she ordered, before you pay the invoice? If so, you live in a flat-sharing community, and you urgently should consider optimizing your process. 
				Automating invoices is still one of the top BPM projects, and the top goal of such projects often is one of parallelization. 				
			</p>
			<h2>Compensation</h2>
			<p>
				We explain the benefit of the compensation event in TODO by means of an example. The compensation task type is applied exclusively in the context of a compensation event. 
				Accordingly, it is integrated in the process diagram only by associations, never by sequence flows. 
			</p>
			<p>
				The possible combination of the compensation with a loop or multiple instance as shown below is worth mentioning. In this case, both markers are placed in parallel. 
				As with the other markers, the compensation can be combined with the task types already introduced. A manual compensation task that repeats until it succeeds or that 
				executes repeatedly and in parallel as far as possible, is therefore eminently practical. 
			</p>
			<div id="task_combinations" style="position:relative" data-bpmn-src="tutorial/task_combinations">
			</div>			
		</section>
		<section id="exclusiveSect">
			<div class="page-header" >
				<h1>Data-based Exclusive Gateways</h1>
			</div>
			<div class="label label-warning">Hover over orange symbols for explanation</div>
			<div  >
				<div id="xor" style="position:relative" data-bpmn-src="tutorial/xor" data-bpmn-run>
					<div class="tutPop" id="sid-433EEF5E-4740-4E48-9503-61C492767C56" rel="popover" title="Data-based Exclusive Gateway (diverging)" data-content="When splitting, this gateway routes the sequence flow to exactly one of the outgoing branches.">
					</div>
					<div class="tutPop" id="sid-47D7385A-388F-40C4-892E-F814C0659C54" rel="popover" title="Data-based Exclusive Gateway (converging)" data-content="
						Certainly, it may make semantic sense to merge the three paths. The meal is eaten after it's prepared, regardless of the recipe chosen. We can use the XOR gateway for merging also, and doing so leads the tokens from the three incoming paths into a single outgoing path.  
					">
					</div>
				</div>
			</div>
			<p>
			Certain things can only be done under certain circumstances, so few processes always take the same course.
			In our simple example, we want to go into the details of cookery. Driven by hunger, we think about what we are going to cook today.
			We only know three recipes, so we choose one. We can either cook pasta <b>or</b> cook a steak <b>or</b> prepare a salad. Let's say that these options are exclusive - we will never prepare more than one at a time. 
			The point of decision on what to do next is called gateway. We decide based on available data (the chosen recipe) and we follow only one of the paths, which is a data-based exclusive gateway. 
			We abbreviate "exclusive gateway" as <b>XOR</b>.  
			</p>
			<p>
				<b>Heads up!</b> Bear in mind that a gateway is not a task! You have to determine facts and needs before reaching a gateway.
			</p>
			<div class="accordion" id="accXOR">
			  <div class="accordion-group">
				<div class="accordion-heading">
				  <a class="accordion-toggle" data-toggle="collapse" data-parent="#accXOR" href="#XORcollapseOne">
					<i class="icon-thumbs-up"></i> Best Practice: Naming Conventions
				  </a>
				</div>
				<div id="XORcollapseOne" class="accordion-body collapse">
				  <div class="accordion-inner">
					<p>
						As in the diagram above, we place the crucial question before the gateway. This is our convention, which has proved its value in our projects. 
						Possible answers go on parallel paths after the gateway, which is how the BPMN specification shows them. We always work with XOR gateways as follows: 
						<ul>
							<li>Model the task that requires a decision for the XOR gateway.</li>
							<li>Model the XOR gateway after that. Create a question with mutually exclusive answers.</li>
							<li>Model one outgoing path (or sequence flow) for each possible answer, and label the path with the answer.</li>
						</ul>
					</p>
				  </div>
				</div>
			  </div>
			  <div class="accordion-group">
				<div class="accordion-heading">
				  <a class="accordion-toggle" data-toggle="collapse" data-parent="#accXOR" href="#XORcollapseTwo">
					<i class="icon-question-sign"></i> FAQ: Do I have to draw the "X"-Marker inside the rhombus? I have already seen that symbol without any marker...
				  </a>
				</div>
				<div id="XORcollapseTwo" class="accordion-body collapse">
				  <div class="accordion-inner">
					BPMN uses two symbols for XOR gateways:
					<div  >
						<div id="xor_marker" style="position:relative" data-bpmn-src="tutorial/xor_marker">
						</div>
					</div>
					<p>
					They are identical in meaning. We always use the version with the X because it seems less ambiguous.
					</p>
				  </div>
				</div>
			  </div>
		  </div>		
		</section>
		<section id="parallelSect">
			<div class="page-header" >
				<h1>Parallel Gateways</h1>
			</div>
			<p>
				Suppose that now we want a salad on the side. If you want salad no matter what, you could model it as we have done in this diagram: 
			</p>
			<div class="label label-warning">Hover over orange symbols for explanation</div>
			<div  style="width:100%; overflow:auto">
				<div id="parallel_without" style="position:relative" data-bpmn-src="tutorial/parallel_without">
					<div class="tutPop" id="sid-A6E3D7E7-B739-4B08-993E-B5CB5F61C69F" rel="popover" title="Text Annotation" data-content="
						Here, we've introduced another symbol, the (text) annotation. This is an artifact that you can associate with any flow object (in this case, tasks). 
						You can enter any text; in our example, we entered the average time to  carry out the associated task.
					">
					</div>
				</div>
			</div>		
			<p>
				The total of the task times equals the running time of the process, which was a total of 48 minutes for pasta and 43 minutes for steak. 
				Congratulations: you've just analyzed your first process based on key data! 
			</p>
			<p>
				Still, this means waiting 23 or even 28 minutes until you can start to eat. Insufferable! You're really hungry, but what can you do? 
				Maybe you don't prepare the salad first and then cook the pasta or the steak, but you work on both at the same time - in parallel. 
				The appropriate symbol is the parallel gateway, or the "AND gateway" for short, as shown in here:			
			</p>
			<div class="label label-warning">Hover over orange symbols for explanation</div>
			<div  style="width:100%; overflow:auto;">
				<div id="parallel" style="position:relative" data-bpmn-src="tutorial/parallel">
					<div class="tutPop" id="sid-2C2A6D8A-860D-46FB-8A18-1663DF783355" rel="popover" title="Parallel Gateway (Diverging)" data-content="
						The token plunges into this Gateway. One token emerges from the gateway for each path. That means two tokens in this example.
					">
					</div>
					<div class="tutPop" id="sid-D18906E5-0DF9-4FF1-A921-4A430C1C379C" rel="popover" title="Parallel Gateway (Converging)" data-content="
				The number of incoming paths determines the number of 
				related tokens the gateway is waiting for, so here, it waits for two tokens, and these must belong to the same process instance. 
				In a Pasta-scenario, the second token arrives at the AND merge after 10 minutes, while the first token stays in 'cook pasta' for a total of 15 minutes.
				This means the AND merge waits until the first token arrives - an additional 5 minutes.
				At that point, the tokens happily merge into a single token, which continues on the outgoing path. 
					">
					</div>
				</div>
			</div>
			<p>
				Diagramming tasks as parallel does not make simultaneous processing compulsory. In contrast to the example shown before, it is also not imperative that you 
				prepare the salad before starting other tasks. Parallel preparation does, however, reduce our total time by 10 minutes. 
				It is classic process optimization to make tasks parallel as much as possible. 
			</p>
			<div class="accordion" id="accAND">
			  <div class="accordion-group">
				<div class="accordion-heading">
				  <a class="accordion-toggle" data-toggle="collapse" data-parent="#accAND" href="#ANDcollapseOne">
					<i class="icon-certificate"></i> Check yourself: What if we draw the same process, but leave the AND merge out for lack of space, 
					and the path from the "prepare salad" task leads directly to the XOR merge. What happens if we instantiate the process, and we decide in favor of pasta?
				  </a>
				</div>
				<div id="ANDcollapseOne" class="accordion-body collapse">
				  <div class="accordion-inner">
						The token is generated and then cloned as always at the AND split. As soon as we finish preparing the salad, the token passes through the XOR merge and "eat meal" executes. Five minutes later,"cook pasta" also completes. Its token passes through the XOR merge and "eat meal" executes again! That's not the behavior we wanted.
						<div  style="width:100%; overflow:auto;">
							<div id="parallel_nomerge" style="position:relative" data-bpmn-src="tutorial/parallel_nomerge">
							</div>
						</div>
				  </div>
				</div>
			  </div>
		  </div>
		</section>		  
		<section id="inclusiveSect">
			<div class="page-header" >
				<h1>Data-based inclusive gateways</h1>
			</div>
			<p>
			We want to make our process even more flexible: When we are hungry, we want to eat 
			<ul>
				<li>Only a salad,</li>
				<li>A salad and "something real," like pasta or steak, or</li>
				<li>Only something real.</li>
			</ul>
			</p>
			<p>
				If you want a more compact representation, you can use the data-based inclusive gateway - the OR gateway for short:
			</p>
				<div class="label label-warning">Hover over orange symbols for explanation</div>		
				<div  style="width:100%; overflow:auto;">
					<div id="or" style="position:relative" data-bpmn-src="tutorial/or">
						<div class="tutPop" id="sid-C39D1115-1E68-48FD-8539-FF41644D24B7" rel="popover" title="Inclusive Gateway (Diverging)" data-content="
							Use OR gateways to describe and/or situations, in which processing can flow along one, many, or all outgoing paths. OR gateways can keep diagrams from becoming overly complex.
						">
						</div>
						<div class="tutPop" id="sid-F843A70C-9AC5-4A9D-BEB9-50D6A3B3F8C7" rel="popover" title="Inclusive Gateway (Converging)" data-content="
							We can use OR gateways to combine paths too: Depending on whether we want to eat just a salad or something real, or a salad and something real, we have to wait either for one token to arrive (merge) or for both tokens (synchronize) before we can eat.
						">
						</div>

					</div>
				</div>		
			<p>
				<b>Heads up!</b> In practice, handling OR gateways is not as simple as these examples imply. It's easy to understand that progress depends on waiting for another token to reach an OR merge. 
				It can be harder to trace the synchronization rules with complex diagrams that sprawl across several pages. 
			</p>
		</section>
		<section id="eventSect">
			<div class="page-header" >
				<h1>Event-based Gateways</h1>
			</div>
			<p>
				We learned about the exclusive data-based (XOR) gateway option as a way to use different paths with regard to the data being processed. 
				Users of other process notations recognize this type of branching, but BPMN gives us another way to design process paths: 
				the event-based gateway - event gateway, for short. This gateway does not route based on data, but rather by which event takes place next. To understand the 
				benefit, consider the process shown below: We order pizza and wait for it to be delivered. We can eat only after we receive the pizza, but what if the pizza doesn't arrive after 60 minutes? 
				We'll make an anxious phone call, that's what! We can model this with the event gateway: 
			</p>
			<div class="label label-warning">Hover over orange symbols for explanation</div>
			<div id="event-based" style="position:relative" data-bpmn-src="tutorial/event-based">
				<div class="tutPop" id="sid-86AEEAF2-E1FF-4EF3-B34E-7ADD4D914B47" rel="popover" title="Event-based Gateway" data-content="
					Now, in contrast to the data-based XOR split, the token waits at the event gateway for one of the subsequent events to occur. Once any one event occurs, the token takes the respective path. 
					If other events then take place, they are ignored. This is XOR semantics. 
					">
				</div>				
			</div>			
			<p>
				As you can see here, not all intermediate events combine with the event gateway. You can, however, combine it with the receive task.
			</p>
			<div id="event-based-events" style="position:relative" data-bpmn-src="tutorial/event-based-events">
			</div>			
		</section>
		<section id="lanesSect">
			<div class="page-header" >
				<h1>Lanes</h1>
			</div>
			<p>
				We have talked about <b>what</b> to do in our processes, but we have not yet explained <b>who</b> is responsible for executing which tasks. In BPMN, you can answer this question with lanes. 
			</p>
				<div class="label label-warning">Hover over orange symbols for explanation</div>
				<div  style="width:100%; overflow:auto;">
					<div id="lanes" style="position:relative" data-bpmn-src="tutorial/lanes">
						<div class="tutPop" id="sid-A6F4B130-61DD-4725-86E0-2E30D1571F9C" rel="popover" title="Lane" data-content="
							A lane is a lane is a lane...
						">
						</div>
						<div class="tutPop" id="sid-F843A70C-9AC5-4A9D-BEB9-50D6A3B3F8C7" rel="popover" title="Inclusive Gateway (Converging)" data-content="
							We can use OR gateways to combine paths too: Depending on whether we want to eat just a salad or something real, or a salad and something real, we have to wait either for one token to arrive (merge) or for both tokens (synchronize) before we can eat.
						">
						</div>

					</div>
				</div>		
		
			<p>
				The diagram shows that the tasks in our sample process were assigned to particular people. We can derive the following process description from the assignments: 
				If Christian is hungry, he chooses a certain recipe. Depending on what Christian chooses, he can either take care of it himself (cook pasta), or he can get his roommates on board. 
				If the latter, Falko cooks steak and Robert prepares salad. In the end, Christian eats. The three lanes (Christian, Falko, Robert) are united in one pool designated "flat-sharing community." 
				(We discuss pools in detail <a href="">TODO here</a>)
			</p>
			<p>
				<div class="accordion" id="accLanes">
				  <div class="accordion-group">
					<div class="accordion-heading">
					  <a class="accordion-toggle" data-toggle="collapse" data-parent="#accLanes" href="#LanescollapseOne">
						<i class="icon-question-sign"></i> FAQ: Do I have to label a lane with a concrete person?
					  </a>
					</div>
					<div id="LanescollapseOne" class="accordion-body collapse">
					  <div class="accordion-inner">
						In the example, lanes equate to people, but this meaning is not specified by BPMN. You can designate the lanes as you like. In practice, lanes are often used to assign:
						<ul>
						<li>Positions in the primary organization, for example, accounting clerk.</li>
						<li>Roles in the secondary organization, for example, data protection officer.</li>
						<li>General roles, for example, customer.</li>
						<li>Departments, for example, sales.</li>
						<li>IT applications, for example, CRM system.</li>
						</ul>
					  </div>
					</div>
				  </div>
				</div>		
			</p>
		</section>			
		</div>
		</div>
</div>
<style>
 .popover {z-index:100 !important;}
</style>
		
      <div class="push-down"><!-- // --></div> 
    </div>
    <!-- footer -->
    <footer class="footer">
      <div data-ng-include=" 'templates/footer.html' "></div>

      <!-- loads all javascript -->
	<script src="assets/js/loader.js"></script>  
    </footer>
  </body>
</html>