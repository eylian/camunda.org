<section id="query-api">

<div class="page-header">
      <h1>Query API</h1>
</div>
  
<div class="row-fluid">
  <div class="span9">
      <p>
        Two query data from the engine is possible in multiple ways:
        <ul>
          <li>Java Query API: Fluent Java API to query engine entities (like ProcessInstances, Tasks, ...).</li>
          <li>REST Query API: REST API to query engine entities (like ProcessInstances, Tasks, ...).</li>
          <li>Native Queries: Provide own SQL queries to retrieve engine entities (like ProcessInstances, Tasks, ...) if the Query API lacks possibilities you need (e.g. OR conditions).</li>
          <li>Custom Queries: Use completly custom queries and an own MyBatis mapping to retrieve own value objects or join engine with domain data.</li>
          <li>SQL Queries: Use database SQL queries for use cases like Reporting.</li>
        </ul>

        The recommended way is to use on of the Query APIs.
      </p>
      <p>
        The Java Query API allows to program completely typesafe queries with a fluent API You can add various conditions to your queries (all of which are applied together as a logical AND) and precisely one ordering. The following code shows an example:

<div class="app-source" app-source-no-tabs="query1" ></div>
<script type="text/xml" id="query1"> 
      List<Task> tasks = taskService.createTaskQuery()
         .taskAssignee("kermit")
         .processVariableValueEquals("orderId", "0815")
         .orderByDueDate().asc()
         .list();
</script>

        You can find more information on this in the <a href="http://www.camunda.org/javadocs/">javadocs</a>.

      </p>
    </div>
    <div class="span3">
      <h3>On this page</h3>
      <ul>            
          <li>Java Query API</li>
          <li>REST Query API</li>
          <li>Native Queries</li>
          <li>Custom Queries</li>
          <li>SQL Queries</li>
      </ul>
      <h3>There's more...</h3>
      <ul>            
          <li><a href="https://app.camunda.com/confluence/display/foxUserGuide/Performance+Tuning+with+custom+Queries">Performance Tuning with custom Queries</a></li>
          <li><a href="https://app.camunda.com/confluence/display/foxUserGuide/Reports+with+BIRT">Reports with BIRT</a></li>
      </ul>      
    </div>
</div>
  

<h1>REST Query API</h1>

The Java Query API is exposed as REST service as well, see <a href="implement-rest.html#/overview/introduction">REST documentation</a> for details.



<h1>Native Queries</h1>
<p>  
Sometimes you need more powerful queries, e.g. queries using an OR operator or restrictions you can not express using the Query API. For these cases, we introduced native queries, which allow you to write your own SQL queries. The return type is defined by the Query object you use and the data is mapped into the correct objects, e.g. Task, ProcessInstance, Execution, etc.... Since the query will be fired at the database you have to use table and column names as they are defined in the database; this requires some knowledge about the internal data structure and it is recommended to use native queries with care. The table names can be retrieved via the API to keep the dependency as small as possible.


    
<div class="app-source" app-source-no-tabs="query2"></div>
<script type="text/xml" id="query2">   
      List<Task> tasks = taskService.createNativeTaskQuery()
        .sql("SELECT count(*) FROM " + managementService.getTableName(Task.class) + " T WHERE T.NAME_ = #{taskName}")
        .parameter("taskName", "gonzoTask")
        .list();

      long count = taskService.createNativeTaskQuery()
        .sql("SELECT count(*) FROM " + managementService.getTableName(Task.class) + " T1, "
               + managementService.getTableName(VariableInstanceEntity.class) + " V1 WHERE V1.TASK_ID_ = T1.ID_")
        .count();
</script>
</p>



<h1>Custom Queries</h1>
<p>
  For performance reasons it might sometimes be desirable not to query the engine objects but some own value or DTO objects collecting data from different tables - maybe including your own domain classes.
</p>
<p>
  See <a href="https://app.camunda.com/confluence/display/foxUserGuide/Performance+Tuning+with+custom+Queries">Performance Tuning with custom Queries</a>.
</p>



<h1>SQL Queries</h1>
<p>
  The table layout is pretty straighforward - we concentrated on making it easy to understand. Hence it is OK to do SQL queries for e.g. reporting use cases. Just make sure that you do not mess up the engine data by updating the tables without exactly knowing what you are doing.
</p>
<p>
  See <a href="https://app.camunda.com/confluence/display/foxUserGuide/Reports+with+BIRT">Reports with BIRT</a> as example use case.
</p>
</section>