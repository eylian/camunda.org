<section id="xxx">

<div class="page-header">
      <h1>Engine Startup via Spring</h1>
</div>
  
<div class="row-fluid">
  <div class="span9">
      <p>
The ProcessEngine can be configured as a regular Spring bean. The starting point of the integration is the class org.camunda.bpm.engine.spring.ProcessEngineFactoryBean. That bean takes a process engine configuration and creates the process engine. This means that the creation and configuration of properties for Spring is the same as documented in the configuration section. For Spring integration the configuration and engine beans will look like this:


<div class="app-source" app-source-no-tabs="spring1" ></div>
<script type="text/xml" id="spring1"> 
<bean id="processEngineConfiguration" 
      class="org.camunda.bpm.engine.spring.SpringProcessEngineConfiguration">
    ...
</bean>
  
<bean id="processEngine" 
      class="org.camunda.bpm.engine.spring.ProcessEngineFactoryBean">
  <property name="processEngineConfiguration" ref="processEngineConfiguration" />
</bean>
</script>
  
Note that the processEngineConfiguration bean uses the <a href="http://www.camunda.org/javadocs/org/camunda/bpm/engine/spring/SpringProcessEngineConfiguration.html">SpringProcessEngineConfiguration</a> class. 
      </p>
    </div>
    <div class="span3">
      <h3>On this page</h3>
      <ul>            
          <li>Service Task</li>
          <li><a href="#">Implementation</a></li>
      </ul>
      <h3>There's more...</h3>
      <ul>            
          <li><a href="tasks.html">Tasks in the BPMN Tutorial</a></li>
          <li><a href="implement-concepts.html#/concepts/error-handling">Error Handling</a></li>
      </ul>      
    </div>
</div>

<h1>Transactions</h1>
  
<p>
  We'll explain the SpringTransactionIntegrationTest found in the Spring examples of the distribution step by step. Below is the Spring configuration file that we use in this example (you can find it in SpringTransactionIntegrationTest-context.xml). The section shown below contains the dataSource, transactionManager, processEngine and the Activiti Engine services.
</p>

<p>
When passing the DataSource to the SpringProcessEngineConfiguration (using property "dataSource"), Activiti uses a org.springframework.jdbc.datasource.TransactionAwareDataSourceProxy internally, which wraps the passed DataSource. This is done to make sure the SQL connections retrieved from the DataSource and the Spring transactions play well together. This implies that it's no longer needed to proxy the dataSource yourself in Spring configuration, although it's still allowed to pass a TransactionAwareDataSourceProxy into the SpringProcessEngineConfiguration. In this case no additional wrapping will occur.
</p>

<p>
Make sure when declaring a TransactionAwareDataSourceProxy in Spring configuration yourself, that you don't use it for resources that are already aware of Spring-transactions (e.g. DataSourceTransactionManager and JPATransactionManager need the un-proxied dataSource).
    
<div class="app-source" app-source-no-tabs="spring2"></div>
<script type="text/xml" id="spring2">   
<beans xmlns="http://www.springframework.org/schema/beans" 
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:tx="http://www.springframework.org/schema/tx"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-2.5.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.0.xsd">

  <bean id="dataSource" class="org.springframework.jdbc.datasource.SimpleDriverDataSource">
    <property name="driverClass" value="org.h2.Driver" />
    <property name="url" value="jdbc:h2:mem:activiti;DB_CLOSE_DELAY=1000" />
    <property name="username" value="sa" />
    <property name="password" value="" />
  </bean>

  <bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
    <property name="dataSource" ref="dataSource" />
  </bean>
  
  <bean id="processEngineConfiguration" class="org.camunda.bpm.engine.spring.SpringProcessEngineConfiguration">
    <property name="dataSource" ref="dataSource" />
    <property name="transactionManager" ref="transactionManager" />
    <property name="databaseSchemaUpdate" value="true" />
    <property name="jobExecutorActivate" value="false" />
  </bean>
  
  <bean id="processEngine" class="org.camunda.bpm.engine.spring.ProcessEngineFactoryBean">
    <property name="processEngineConfiguration" ref="processEngineConfiguration" />
  </bean>
  
  <bean id="repositoryService" factory-bean="processEngine" factory-method="getRepositoryService" />
  <bean id="runtimeService" factory-bean="processEngine" factory-method="getRuntimeService" />
  <bean id="taskService" factory-bean="processEngine" factory-method="getTaskService" />
  <bean id="historyService" factory-bean="processEngine" factory-method="getHistoryService" />
  <bean id="managementService" factory-bean="processEngine" factory-method="getManagementService" />

...
</script>

</p>

<p>
The remainder of that Spring configuration file contains the beans and configuration that we'll use in this particular example:
    
<div class="app-source" app-source-no-tabs="spring3"></div>
<script type="text/xml" id="spring3">   
<beans>  
  ...
  <tx:annotation-driven transaction-manager="transactionManager"/>

  <bean id="userBean" class="org.activiti.spring.test.UserBean">
    <property name="runtimeService" ref="runtimeService" />
  </bean>

  <bean id="printer" class="org.activiti.spring.test.Printer" />

</beans>
</script>
</p>

<p>
First the application context is created with any of the Spring ways to do that. In this example you could use a classpath XML resource to configure our Spring application context:
    
<div class="app-source" app-source-no-tabs="spring4"></div>
<script type="text/xml" id="spring4">   
ClassPathXmlApplicationContext applicationContext = 
    new ClassPathXmlApplicationContext("mytest/SpringTransactionIntegrationTest-context.xml");
</script>

or, since it is a test:
  
<div class="app-source" app-source-no-tabs="spring5"></div>
<script type="text/xml" id="spring5">   
@ContextConfiguration("classpath:mytest/SpringTransactionIntegrationTest-context.xml")
</script>
</p>

<p>
Then we can get the service beans and invoke methods on them. The ProcessEngineFactoryBean will have added an extra interceptor to the services that applies Propagation.REQUIRED transaction semantics on the engine service methods. So, for example, we can use the repositoryService to deploy a process like this:

    
<div class="app-source" app-source-no-tabs="spring6"></div>
<script type="text/xml" id="spring6">   
RepositoryService repositoryService = (RepositoryService) applicationContext.getBean("repositoryService");
String deploymentId = repositoryService
  .createDeployment()
  .addClasspathResource("mytest/hello.bpmn20.xml")
  .deploy()
  .getId();
</script>
    

The other way around also works. In this case, the Spring transaction will be around the userBean.hello() method and the Activiti service method invocation will join that same transaction.

    <div class="app-source" app-source-no-tabs="spring7"></div>
<script type="text/xml" id="spring7">   
UserBean userBean = (UserBean) applicationContext.getBean("userBean");
userBean.hello();
</script>

The UserBean looks like this. Remember from above in the Spring bean configuration we injected the repositoryService into the userBean.
    
<div class="app-source" app-source-no-tabs="spring8"></div>
<script type="text/xml" id="spring8">   
public class UserBean {

  /** injected by Spring */
  private RuntimeService runtimeService;

  @Transactional
  public void hello() {
    // here you can do transactional stuff in your domain model
    // and it will be combined in the same transaction as 
    // the startProcessInstanceByKey to the Activiti RuntimeService
    runtimeService.startProcessInstanceByKey("helloProcess");
  }
  
  public void setRuntimeService(RuntimeService runtimeService) {
    this.runtimeService = runtimeService;
  }
}	
</script>
</p>






<h1>Automatic resource deployment</h1>
<p>
Spring integration also has a special feature for deploying resources. In the process engine configuration, you can specify a set of resources. When the process engine is created, all those resources will be scanned and deployed. There is filtering in place that prevents duplicate deployments. Only when the resources actually have changed, will new deployments be deployed to the Activiti DB. This makes sense in a lot of use case, where the Spring container is rebooted often (e.g. testing).
</p>
<p>
Here's an example:
    
<div class="app-source" app-source-no-tabs="springConf"></div>
<script type="text/xml" id="springConf">   
<bean id="processEngineConfiguration" class="org.camunda.bpm.engine.spring.SpringProcessEngineConfiguration">
  ...
  <property name="deploymentResources" value="classpath*:/mytest/autodeploy.*.bpmn20.xml" />
</bean>
  
<bean id="processEngine" class="org.camunda.bpm.engine.spring.ProcessEngineFactoryBean">
  <property name="processEngineConfiguration" ref="processEngineConfiguration" />
</bean>
</script>




	
</section>