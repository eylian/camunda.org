
<header class="hero-unit" id="overview">
  <div class="center">
    <h1>BPMN 2.0 Tutorial</h1>
    <h2>Mastering the Global Standard for Process Modeling</h2>
  </div>
</header>

<div class="container">
	<!--<div tutorial="partials/design/tutorial.md" />-->
	<div class="row">
      <div id="navSide" class="span3 bs-docs-sidebar" >
        <ul class="nav nav-list bs-docs-sidenav" data-spy="affix" >
          <li ><a href="#intro"><i class="icon-chevron-right"></i> Introduction</a></li>
          <li><a href="#simpleSect"><i class="icon-chevron-right"></i> A simple flow</a></li>
		  <li><a href="#gatewaysSect"><i class="icon-chevron-right"></i> Gateways</a></li>
		  <li><a href="#lanesSect"><i class="icon-chevron-right"></i> Lanes</a></li>		   		  
          <li><a href="#eventsSect"><i class="icon-chevron-right"></i> Events</a></li>
          <li><a href="#subprocessesSect"><i class="icon-chevron-right"></i> Subprocesses</a></li>
          <li><a href="#collaborationSect"><i class="icon-chevron-right"></i> Collaboration Diagrams</a></li>
		</ul>
      </div>

     <div class="span9"  >
		<section id="intro">
			<div class="page-header" >
				<h1>Introduction<small> Why should I care about BPMN 2.0?</small></h1>
			</div>
			<p>
Business Process Model and Notation (BPMN) is the global standard for process modelling and one of the most important components of a successful Business-IT-Alignment.
</p>
<p>
More and more organisations are using BPMN and in more and more universities BPMN is taught as a subject. These are the reasons:
</p>
<dl class="dl-horizontal">
				  <dt>Standard</dt>
				  <dd>BPMN is not owned by a certain enterprise but by an institution (<a href="http://www.omg.org">OMG</a>), which is already established through other world-wide standards, e.g. UML. The standard is supported by many software products; you are less dependent on any particular vendor's products.</dd>
				  <dt>Simplicity</dt>
				  <dd>The principle behind BPMN is rather simple which is why you can very quickly work with this notation.</dd>
				  <dt>Power of expression</dt>
				  <dd>If necessary, with BPMN you can describe precisely how a process functions. This is however more difficult than describing the process only roughly. This way of precise modelling is possible, but not mandatory.</dd>
				  <dt>Implementation in IT</dt>
				  <dd>BPMN has been primarily developed to support a technical implementation of processes ("Process Automation"). The more important the IT is in a company, the more helpful is the use of BPMN.</dd>
				  </dl>	
			
			<p>
			In this tutorial you will learn the essentials of BPMN 2.0. We will briefly describe the meaning of the symbols, and how you can use them for process mapping. We will also refer to the respective section covering the use in camunda bpm, when it comes to process automation.
			
			If you want to get a deeper understanding of BPMN 2.0, please check out our BPMN handbook or <a href="http://www.camunda.com/consulting/bpmn/overview/">attend/book a training</a>.
			</p>
			<div class="row-fluid">
				<div class="span4">
					<div class="span4">
					<img src="http://ecx.images-amazon.com/images/I/41XSes77XSL._SL135_.jpg"/>
					</div>
					<div class="span8">
					<p>
						<img src="http://www.bpm-guide.de/wp-content/plugins/polyglot2/polyglot_flags/uk.png"> English Edition<br/>
						<b>Real Life BPMN</b></p>
						<p><a c href="http://www.amazon.com/Real-Life-BPMN-Analyze-Automate-Processes/dp/1480034983">Get at Amazon.com</a>
					</div>
				</div>
				<div class="span4">
					<div class="span4">
					<img src="http://ecx.images-amazon.com/images/I/414DcF8OJaL._SL135_.jpg" />
					</div>
					<div class="span8">
					<p>
						<img src="http://www.bpm-guide.de/wp-content/plugins/polyglot2/polyglot_flags/es.png"> Spanish Edition<br/>
						<b>BPMN 2.0 Manual</b></p>
						<p><a href="http://www.amazon.com/BPMN-Manual-Referencia-Práctica-Spanish/dp/1460903935">Get at Amazon.com</a>
					</div>
					
				</div>
				<div class="span4">
					<div class="span4">
					<img src="http://files.hanser.de/hanser/pics/978-3-446-42986-4_2122714399-110.jpg" />
					</div>
					<div class="span8">
					<p>
						<img src="http://www.bpm-guide.de/wp-content/plugins/polyglot2/polyglot_flags/de.png"> German Edition<br/>
						<b>Praxishandbuch BPMN</b></p>
						<p><a href="http://www.amazon.de/Praxishandbuch-BPMN-2-0-Jakob-Freund/dp/3446429867">Get at Amazon.de</a>
					</div>
				</div>
			</div>
		</section>		
		<section id="simpleSect">
			<div class="page-header" >
				<h1>A simple flow</h1>
			</div>
			<div class="label label-warning">Hover over orange symbols for explanation</div>
				<div id="simple" style="position:relative">
					<script>
					bpmn("tutorial/simple_flow", "simple");
					</script>
					<div class="tutPop" id="simple-sid-B04D1D48-F63A-440D-8354-072FEA072E41" rel="popover" title="Start Event" data-content="Start events show which event causes the process to start. Start Evens are always catching events.">
					</div>
					<div class="tutPop" id="simple-sid-4A1FEF34-88D7-4845-940F-9C048C11B5A6" rel="popover" title="Task" data-content="Tasks are the heart of the process. Ultimately, something has to happen to bring about a desired outcome. In BPMN, a task technically is part of the activities category, which also includes the sub-process">
					</div>
					<div class="tutPop" id="simple-sid-BC888BAA-90B0-4173-ACAA-F1621EE71B2D" rel="popover" title="Intermediate Event" data-content="Intermediate events stand for a status that is reached in the process and that is modeled explicitly. They are used infrequently, but intermediate events can be useful, for example, if you regard reaching a certain status as a milestone and you want to measure the time until the milestone is reached. Intermeidate none events are always throwing events.">
					</div>
					<div class="tutPop" id="simple-sid-153C934A-CC9F-4169-A816-6CBE7B159D1E" rel="popover" title="End Event" data-content="End events mark the status reached at the end of the process path. End events are always throwing events.">
					</div>
				</div>


			<p>
				This diagram shows a simple process triggered by someone being hungry. The result is that someone must shop for groceries and prepare a meal. After that, someone will eat the meal and have his or her hunger satisfied. 
			</p>
			<div class="accordion" id="accSimple">
			  <div class="accordion-group">
				<div class="accordion-heading">
				  <a class="accordion-toggle" data-toggle="collapse" data-parent="#accSimple" href="#collapseOne">
					<i class="icon-thumbs-up"></i> Best Practice: Naming Conventions
				  </a>
				</div>
				<div id="collapseOne" class="accordion-body collapse">
				  <div class="accordion-inner">
							<p>
							When naming tasks, we try to adhere to the object-orientated design principle of using the [verb] + [object] pattern. We would say "acquire groceries," for example, not "first take care of shopping for groceries." 
							</p>
							<p>
							Events refer to something that has already happened regardless of the process (if they are catching events) and as a result of the process (if they are throwing events). For this reason, we use the [object] and make the [verb] passive in voice, so we write "hunger noticed." BPMN does not require you to model start and end events for a process - you can leave them out - but <b>if</b> you model a start event, you must model an end event for each path. The same is true for end events that require start events. We always create our models with start and end events for two reasons: first, that way it's possible to determine the process trigger, and second, you can describe the final status of each path end. We only sometimes abandon this practice with sub-processes. More on this later.				
							</p>
				  </div>
				</div>
			  </div>
			  <div class="accordion-group">
				<div class="accordion-heading">
				  <a class="accordion-toggle" data-toggle="collapse" data-parent="#accSimple" href="#collapseTwo">
					<i class="icon-question-sign"></i> FAQ: Is it obligatory to draw BPMN diagrams horizontally? What if I prefer to draw them vertically?
				  </a>
				</div>
				<div id="collapseTwo" class="accordion-body collapse">
				  <div class="accordion-inner">
							You could always draw your diagrams from top to bottom instead fom left to right - the BPMN 2.0 standard does not forbid it. However we do not recommend it: It is very uncommon, and experience has proven that people tend to understand the process flow better if it is described in the same way like written text (from left to right, at least in the western world).
				  </div>
				</div>
			  </div>
			</div>			
		</section>
		<section id="gatewaysSect">
			<div class="page-header" >
				<h1>Gateways</h1>
			</div>
			
			<h2>Data-based Exclusive Gateways</h2>
			<div class="label label-warning">Hover over orange symbols for explanation</div>
			<div  >
				<div id="xor" style="position:relative">
					<script>
						bpmn("tutorial/xor", "xor");
					</script>
					<div class="tutPop" id="xor-sid-433EEF5E-4740-4E48-9503-61C492767C56" rel="popover" title="Data-based Exclusive Gateway (diverging)" data-content="When splitting, this gateway routes the sequence flow to exactly one of the outgoing branches.">
					</div>
					<div class="tutPop" id="xor-sid-47D7385A-388F-40C4-892E-F814C0659C54" rel="popover" title="Data-based Exclusive Gateway (converging)" data-content="
						Certainly, it may make semantic sense to merge the three paths. The meal is eaten after it's prepared, regardless of the recipe chosen. We can use the XOR gateway for merging also, and doing so leads the tokens from the three incoming paths into a single outgoing path.  
					">
					</div>
				</div>
			</div>
			<p>
			Certain things can only be done under certain circumstances, so few processes always take the same course.
			In our simple example, we want to go into the details of cookery. Driven by hunger, we think about what we are going to cook today.
			We only know three recipes, so we choose one. We can either cook pasta <b>or</b> cook a steak <b>or</b> prepare a salad. Let's say that these options are exclusive - we will never prepare more than one at a time. 
			The point of decision on what to do next is called gateway. We decide based on available data (the chosen recipe) and we follow only one of the paths, which is a data-based exclusive gateway. 
			We abbreviate "exclusive gateway" as <b>XOR</b>.  
			</p>
			<p>
				<b>Heads up!</b> Bear in mind that a gateway is not a task! You have to determine facts and needs before reaching a gateway.
			</p>
			<div class="accordion" id="accXOR">
			  <div class="accordion-group">
				<div class="accordion-heading">
				  <a class="accordion-toggle" data-toggle="collapse" data-parent="#accXOR" href="#XORcollapseOne">
					<i class="icon-thumbs-up"></i> Best Practice: Naming Conventions
				  </a>
				</div>
				<div id="XORcollapseOne" class="accordion-body collapse">
				  <div class="accordion-inner">
					<p>
						As in the diagram above, we place the crucial question before the gateway. This is our convention, which has proved its value in our projects. 
						Possible answers go on parallel paths after the gateway, which is how the BPMN specification shows them. We always work with XOR gateways as follows: 
						<ul>
							<li>Model the task that requires a decision for the XOR gateway.</li>
							<li>Model the XOR gateway after that. Create a question with mutually exclusive answers.</li>
							<li>Model one outgoing path (or sequence flow) for each possible answer, and label the path with the answer.</li>
						</ul>
					</p>
				  </div>
				</div>
			  </div>
			  <div class="accordion-group">
				<div class="accordion-heading">
				  <a class="accordion-toggle" data-toggle="collapse" data-parent="#accXOR" href="#XORcollapseTwo">
					<i class="icon-question-sign"></i> FAQ: Do I have to draw the "X"-Marker inside the rhombus? I have already seen that symbol without any marker...
				  </a>
				</div>
				<div id="XORcollapseTwo" class="accordion-body collapse">
				  <div class="accordion-inner">
					BPMN uses two symbols for XOR gateways:
					<div  >
						<div id="xor_marker" style="position:relative">
							<script>
								bpmn("tutorial/xor_marker", "xor_marker");
							</script>
						</div>
					</div>
					<p>
					They are identical in meaning. We always use the version with the X because it seems less ambiguous.
					</p>
				  </div>
				</div>
			  </div>
		  </div>			
			<h2>Parallel Gateways</h2>
			<p>
				Suppose that now we want a salad on the side. If you want salad no matter what, you could model it as we have done in this diagram: 
			</p>
			<div class="label label-warning">Hover over orange symbols for explanation</div>
			<div  style="width:100%; overflow:auto">
				<div id="parallel_without" style="position:relative">
					<script>
						bpmn("tutorial/parallel_without", "parallel_without");
					</script>
					<div class="tutPop" id="parallel_without-sid-A6E3D7E7-B739-4B08-993E-B5CB5F61C69F" rel="popover" title="Text Annotation" data-content="
						Here, we've introduced another symbol, the (text) annotation. This is an artifact that you can associate with any flow object (in this case, tasks). 
						You can enter any text; in our example, we entered the average time to  carry out the associated task.
					">
					</div>
				</div>
			</div>		
			<p>
				The total of the task times equals the running time of the process, which was a total of 48 minutes for pasta and 43 minutes for steak. 
				Congratulations: you've just analyzed your first process based on key data! 
			</p>
			<p>
				Still, this means waiting 23 or even 28 minutes until you can start to eat. Insufferable! You're really hungry, but what can you do? 
				Maybe you don't prepare the salad first and then cook the pasta or the steak, but you work on both at the same time - in parallel. 
				The appropriate symbol is the parallel gateway, or the "AND gateway" for short, as shown in here:			
			</p>
			<div class="label label-warning">Hover over orange symbols for explanation</div>
			<div  style="width:100%; overflow:auto;">
				<div id="parallel" style="position:relative">
					<script>
						bpmn("tutorial/parallel", "parallel");
					</script>
					<div class="tutPop" id="parallel-sid-2C2A6D8A-860D-46FB-8A18-1663DF783355" rel="popover" title="Parallel Gateway (Diverging)" data-content="
						The token plunges into this Gateway. One token emerges from the gateway for each path. That means two tokens in this example.
					">
					</div>
					<div class="tutPop" id="parallel-sid-D18906E5-0DF9-4FF1-A921-4A430C1C379C" rel="popover" title="Parallel Gateway (Converging)" data-content="
				The number of incoming paths determines the number of 
				related tokens the gateway is waiting for, so here, it waits for two tokens, and these must belong to the same process instance. 
				In a Pasta-scenario, the second token arrives at the AND merge after 10 minutes, while the first token stays in 'cook pasta' for a total of 15 minutes.
				This means the AND merge waits until the first token arrives - an additional 5 minutes.
				At that point, the tokens happily merge into a single token, which continues on the outgoing path. 
					">
					</div>
				</div>
			</div>
			<p>
				Diagramming tasks as parallel does not make simultaneous processing compulsory. In contrast to the example shown before, it is also not imperative that you 
				prepare the salad before starting other tasks. Parallel preparation does, however, reduce our total time by 10 minutes. 
				It is classic process optimization to make tasks parallel as much as possible. 
			</p>
			<div class="accordion" id="accAND">
			  <div class="accordion-group">
				<div class="accordion-heading">
				  <a class="accordion-toggle" data-toggle="collapse" data-parent="#accAND" href="#ANDcollapseOne">
					<i class="icon-certificate"></i> Check yourself: What if we draw the same process, but leave the AND merge out for lack of space, 
					and the path from the "prepare salad" task leads directly to the XOR merge. What happens if we instantiate the process, and we decide in favor of pasta?
				  </a>
				</div>
				<div id="ANDcollapseOne" class="accordion-body collapse">
				  <div class="accordion-inner">
						The token is generated and then cloned as always at the AND split. As soon as we finish preparing the salad, the token passes through the XOR merge and "eat meal" executes. Five minutes later,"cook pasta" also completes. Its token passes through the XOR merge and "eat meal" executes again! That's not the behavior we wanted.
						<div  style="width:100%; overflow:auto;">
							<div id="parallel_nomerge" style="position:relative">
								<script>
									bpmn("tutorial/parallel_nomerge", "parallel_nomerge");
								</script>
							</div>
						</div>
				  </div>
				</div>
			  </div>
		  </div>		
			<h2>Data-based inclusive gateway</h2>
			We want to make our process even more flexible: When we are hungry, we want to eat 
			<ul>
				<li>Only a salad,</li>
				<li>A salad and "something real," like pasta or steak, or</li>
				<li>Only something real.</li>
			</ul>
			<p>
				If you want a more compact representation, you can use the data-based inclusive gateway - the OR gateway for short:
			</p>
				<div class="label label-warning">Hover over orange symbols for explanation</div>		
				<div  style="width:100%; overflow:auto;">
					<div id="or" style="position:relative">
						<script>
							bpmn("tutorial/or", "or");
						</script>
						<div class="tutPop" id="or-sid-C39D1115-1E68-48FD-8539-FF41644D24B7" rel="popover" title="Inclusive Gateway (Diverging)" data-content="
							Use OR gateways to describe and/or situations, in which processing can flow along one, many, or all outgoing paths. OR gateways can keep diagrams from becoming overly complex.
						">
						</div>
						<div class="tutPop" id="or-sid-F843A70C-9AC5-4A9D-BEB9-50D6A3B3F8C7" rel="popover" title="Inclusive Gateway (Converging)" data-content="
							We can use OR gateways to combine paths too: Depending on whether we want to eat just a salad or something real, or a salad and something real, we have to wait either for one token to arrive (merge) or for both tokens (synchronize) before we can eat.
						">
						</div>

					</div>
				</div>		
			<p>
				<b>Heads up!</b> In practice, handling OR gateways is not as simple as these examples imply. It's easy to understand that progress depends on waiting for another token to reach an OR merge. 
				It can be harder to trace the synchronization rules with complex diagrams that sprawl across several pages. 
			</p>
		</section>
		<section id="lanesSect">
			<div class="page-header" >
				<h1>Lanes</h1>
			</div>
			<p>
				We have talked about <b>what</b> to do in our processes, but we have not yet explained <b>who</b> is responsible for executing which tasks. In BPMN, you can answer this question with lanes. 
			</p>
				<div class="label label-warning">Hover over orange symbols for explanation</div>
				<div  style="width:100%; overflow:auto;">
					<div id="lanes" style="position:relative">
						<script>
							bpmn("tutorial/lanes", "lanes");
						</script>
						<div class="tutPop" id="lanes-sid-A6F4B130-61DD-4725-86E0-2E30D1571F9C" rel="popover" title="Lane" data-content="
							A lane is a lane is a lane...
						">
						</div>
						<div class="tutPop" id="or-sid-F843A70C-9AC5-4A9D-BEB9-50D6A3B3F8C7" rel="popover" title="Inclusive Gateway (Converging)" data-content="
							We can use OR gateways to combine paths too: Depending on whether we want to eat just a salad or something real, or a salad and something real, we have to wait either for one token to arrive (merge) or for both tokens (synchronize) before we can eat.
						">
						</div>

					</div>
				</div>		
		
			<p>
				The diagram shows that the tasks in our sample process were assigned to particular people. We can derive the following process description from the assignments: 
				If Christian is hungry, he chooses a certain recipe. Depending on what Christian chooses, he can either take care of it himself (cook pasta), or he can get his roommates on board. 
				If the latter, Falko cooks steak and Robert prepares salad. In the end, Christian eats. The three lanes (Christian, Falko, Robert) are united in one pool designated "flat-sharing community." 
				(We discuss pools in detail <a href="">TODO here</a>)
			</p>
			<p>
				<div class="accordion" id="accLanes">
				  <div class="accordion-group">
					<div class="accordion-heading">
					  <a class="accordion-toggle" data-toggle="collapse" data-parent="#accLanes" href="#LanescollapseOne">
						<i class="icon-question-sign"></i> FAQ: Do I have to label a lane with a concrete person?
					  </a>
					</div>
					<div id="LanescollapseOne" class="accordion-body collapse">
					  <div class="accordion-inner">
						In the example, lanes equate to people, but this meaning is not specified by BPMN. You can designate the lanes as you like. In practice, lanes are often used to assign:
						<ul>
						<li>Positions in the primary organization, for example, accounting clerk.</li>
						<li>Roles in the secondary organization, for example, data protection officer.</li>
						<li>General roles, for example, customer.</li>
						<li>Departments, for example, sales.</li>
						<li>IT applications, for example, CRM system.</li>
						</ul>
					  </div>
					</div>
				  </div>
				</div>		
			</p>

		</section>
		<section id="eventsSect">
			<div class="page-header" >
				<h1>Events</h1>
			</div>
			<h2>Basic Concepts</h2>
			<p>
				Tasks and gateways are two of three flow elements we've come to know so far: Things (tasks) have to be done under certain circumstances (gateways). What flow element is still missing? 
				The things (events) that are supposed to happen. Events are no less important for BPMN process models than tasks or gateways. We should start with some basic principles for applying them. 
				We already saw Start events, intermediate events, and end events. Those three event types are also catching and/or throwing events:
			</p>
			<p>
				<b>Catching events</b> are events with a defined trigger. We consider that they take place once the trigger has activated or fired. As an intellectual construct, that is relatively intricate, 
				so we simplify by calling them catching events. The point is that these events influence the course of the process and therefore must be modeled. Catching events may result in:
				<ul>
					<li>The process starting</li>
					<li>The process or a process path continuing</li>
					<li>The task currently processed or the sub-process being canceled</li>
					<li>Another process path being used while a task or a sub-process executes</li>
				</ul>
			</p>
			<p>
				<b>Throwing events</b> are assumed by BPMN to trigger themselves instead of reacting to a trigger. You could say that they are active compared to passive catching events. 
				We call them throwing events for short, because the process triggers them. Throwing events can be:
				<ul>
					<li>Triggered during the process</li>
					<li>Triggered at the end of the process</li>
				</ul>
			</p>
			
			<p>
			We can also model attached intermediate events with BPMN. These do not explicitly require waiting, but they do interrupt our activities, both tasks and sub-processes. 
			Such intermediate events are attached because we position them at the boundary of the activity we want to interrupt. 
			</p>
			<div class="label label-warning">Hover over orange symbols for explanation</div>
			<div id="boundary" style="position:relative">
				<script>
					bpmn("tutorial/boundary", "boundary");
				</script>
				<div class="tutPop" id="boundary-sid-CF6B2EA1-1671-4A0C-BBFC-819B8C7C0A37" rel="popover" title="Boundary Event" data-content="
					If this event occurs while task 1 is active, task 1 will be canceled and task 3 completed instead.
				">
				</div>
			</div>
			
			<p>
				A token running through the process would behave this way: 
				<ul>
					<li>The token moves to task 1, which starts accordingly.</li>
					<li>If event 1 occurs while task 1 is being processed, task 1 is immediately canceled, and the token moves through the exception flow to task 3.</li>
					<li>On the other hand, if event 1 does not occur, task 1 will be processed, and the token moves through the regular sequence flow to task 2.</li>
					<li>If event 1 occurs only after task 1 completes, it will be ignored.</li>
				</ul>
			</p>
			<p>
				Through BPMN version 1.2, with the exception of compensation events, attached intermediate events inevitably resulted in canceled activities. BPMN 2.0 defines a new symbol: 
				the non-interrupting intermediate event. It sounds awkward, but it is useful:
			</p>
			<div class="label label-warning">Hover over orange symbols for explanation</div>
			<div id="boundary-non-interrupt" style="position:relative">
				<script>
					bpmn("tutorial/boundary-non-interrupt", "boundary-non-interrupt");
				</script>
				<div class="tutPop" id="boundary-non-interrupt-sid-CF6B2EA1-1671-4A0C-BBFC-819B8C7C0A37" rel="popover" title="Boundary Event (not interrupting)" data-content="
					If this event occurs while task 1 is active, task 1 will still get completed and task 3 will also get completed.
				">
				</div>
			</div>
			<p>
				The token moves through the process as follows:
				<ul>
					<li>The token moves to task 1, which starts accordingly.</li>
					<li>If event 1 occurs while task 1 is being processed, the token is cloned. Task 1 continues to be processed while the second token moves to task 3, which is now also processed. 
					This procedure may even take place repeatedly, that is, the event can occur many times. Each occurrence results in another cloned token.</li>
					<li>If event 1 does <b>not</b> occur, task 1 will be completed, and the token moves through the regular sequence flow to task 2.</li>
					<li>If event 1 occurs only after task 1 completes, it ceases to matter.</li>
				</ul>
				In the following sections, we introduce the event types to be used when working with BPMN. We also explain how you can react to different events using the event-based gateway.
			</p>
			
			<h2>Message Events</h2>
			<p>
				Sooner or later, most processes require communication, which can be represented in BPMN by means of the message event.
				You'll recognize it as the small envelope. The meaning of "message" in BPMN is not restricted to letters, e-mails, or calls. Any action that refers to a specific addressee 
				and represents or contains information for the addressee is a message. 
			</p>
				<div class="label label-warning">Hover over orange symbols for explanation</div>
				<div id="message" style="position:relative">
					<script>
						bpmn("tutorial/message", "message");
					</script>
					<div class="tutPop" id="message-sid-052EC62A-7B81-430F-A27A-821F7758C181" rel="popover" title="Intermediate Message Event" data-content="
						In this example, the pizza ordering issue has been fully modeled: We choose a pizza, and we order it. We then wait for the pizza to be delivered. After delivery, we eat. 
					">
					</div>
				</div>
			<p>
			<div class="accordion" id="accMessageThrow">
			  <div class="accordion-group">
				<div class="accordion-heading">
				  <a class="accordion-toggle" data-toggle="collapse" data-parent="#accMessageThrow" href="#MessageThrowcollapseOne">
					<i class="icon-question-sign"></i> FAQ: Could I replace the task "order pizza" with a throwing message event?
				  </a>
				</div>
				<div id="MessageThrowcollapseOne" class="accordion-body collapse">
				  <div class="accordion-inner">
							<p>
							Yes, you could:
							</p>
								<div id="message_throw" style="position:relative">
									<script>
										bpmn("tutorial/message_throw", "message_throw");
									</script>
								</div>			
							<p>
								<b>Heads up!</b> We are not always happy with the throwing intermediate event. Implying a "send message" task without modeling it explicitly can easily confuse 
								inexperienced consumers of our models. We choose not to use throwing intermediate events for messages and instead use a task. 
								There are also special BPMN task types for sending and receiving messages.
							</p>
				  </div>
				</div>
			  </div>
			 </p>
			<p>
				In the example below, we show a message leading to cancellation. In this scenario, we administer a web application. When a user notifies us that the website does not work, we 
				immediately search for the error. But maybe the user is mistaken, and the website is fine. Maybe the user's Internet connection is defective. If the user tells us about the false alarm,
				we cancel the search and swear at the user for wasting our time. If the error is actually found, however, we eliminate it and simultaneously figure out who caused the error. If the user caused 
				the error, we can swear at the user for a different reason. If the user is not at fault, however, we thank him or her graciously for letting us know about the problem. 				
			</p>

			  <div id="message_boundary" style="position:relative">
				<script>
					bpmn("tutorial/message_boundary", "message_boundary");
				</script>
			</div>			
			
			<h2>Timer Events</h2>
			<p>
				The timer event is often used when working with BPMN because it is so flexible to apply. A clock icon represents the timer event. The diagram below shows a few examples of applications:
			</p>
			<div id="timer_examples" style="position:relative">
				<script>
					bpmn("tutorial/timer_examples", "timer_examples");
				</script>
			</div>	
			<p>
				Time moves on no matter what we or our processes do, so timer events can exist only as catching starts or intermediate events.
			</p>
			<p>
				You can model countdown times with an attached timer event. They are used this way frequently. You can specify upper time limits - the maximum time allowed for a processing task - for instance:
			</p>
			<div class="label label-warning">Hover over orange symbols for explanation</div>
			<div id="timer_boundary" style="position:relative">
				<script>
					bpmn("tutorial/timer_boundary", "timer_boundary");
				</script>
				<div class="tutPop" id="timer_boundary-sid-93878818-A560-4B99-946C-C8DA3EED2761" rel="popover" title="Timer Boundary Event" data-content="
					The task this event is attached to may take a maximum of 30 minutes. If the time expires before the task completes, the 'choose pizza' task is canceled, and we cook pasta instead. In either case, we eat the meal at the end. 
				">
				</div>
			</div>	
			<p>Non-interrupting timer events became possible with BPMN 2.0:</p>
			<div class="label label-warning">Hover over orange symbols for explanation</div>			
			<div id="timer_boundary_non-interrupt" style="position:relative">
				<script>
					bpmn("tutorial/timer_boundary_non-interrupt", "timer_boundary_non-interrupt");
				</script>
				<div class="tutPop" id="timer_boundary_non-interrupt-sid-45B9AF9C-16E7-4A43-80C5-C1B7D04F0DDE" rel="popover" title="Timer Boundary Event" data-content="
					Before we can eat, we have to prepare the meal and set the table, but we only start setting the table 10 minutes before the meal is ready. 
				">
				</div>
			</div>
			<h2>Error Events</h2>
			<p>
				Do your processes run completely error-free? If not, you can identify potential errors in your models as a step toward eliminating them, or as part of modeling escalation processes. 
				In BPMN, error events are represented by a flash symbol.
			</p>
			<p>
				The BPMN specification does not specify what an error may be. As the modeler, you have to decide that.
			</p>
			<p>
				An error is a serious event in BPMN, so if catching, it can be modeled only as an attached intermediate event. This means that an error during task execution must be handled in a specific way: 
				As a throwing event, it can be modeled only at the end of a process path so that the participant knows the process has failed. The parent process should likewise recognize the failure. (We explain the interaction between parent  and sub-processes here TODO. You'll also find an example of applying an error event there.) 
			</p>
			<h2>Conditional Events</h2>
			<p>
				Sometimes we only want a process to start or to continue if a certain condition is true. Anything can be a condition, and conditions are independent of processes, 
				which is why the condition (like the timer event) can only exist as a catching event. A process cannot therefore conditional event trigger a conditional event. 
			</p>
			<p>
				We can enhance our pizza process with conditions. If we want to have frozen pizza, the process starts as shown in the diagram below. We take the pizza from the freezer and turn on the oven. 
				But only after the temperature in the oven reaches 180 C do we put the pizza in, and only after it is done do we take it out to eat.  
			</p>
			<div id="conditional" style="position:relative">
				<script>
					bpmn("tutorial/conditional", "conditional");
				</script>
			</div>
			<h2>Signal Events</h2>
			<p>
				Signals are similar to messages, which is why you can model them in BPMN as events just as you can with messages. 
				The symbol for a signal is a triangle. The essential difference between a signal and a message is that that latter is always addressed to a specific recipient. 
				(An e-mail contains the e-mail address of the recipient, a call starts with dialing the telephone number, and so on.) 
				In contrast, a signal is more like a newspaper advertisement or a television commercial. It is relatively undirected. Anyone who receives the signal and wants to react may do so.  
			</p>
			<div id="signal" style="position:relative">
				<script>
					bpmn("tutorial/signal", "signal");
				</script>
			</div>			
			<p>
				We saw a new frozen pizza on TV, and we are keen to try it. The diagram above illustrates this new situation. We buy the pizza, but we keep it in the freezer until we're really hungry for pizza. 
				That's a conditional event. After trying the new pizza, we go to Pizzatest.de to rate the new product. That's a signal. It is a signal for the general public too. 
				(Pizzatest.de actually exists, by the way, which proves again that you can find simply <b>everything</b> on the Internet!) 			
			</p>
			<h2>Terminate Events</h2>
			<p>
				Let's look at the abstract example below. We already discussed (simple) Key Performance Indicator (KPI) analysis, and we therefore know that this process always takes 55 minutes. 
				After task 1, tasks 2 and 3 can be processed simultaneously. Processing task 2 takes more time than does processing task 3, which is why it determines the runtime of the process. 
				A token that runs through the process is cloned in the AND split. The first token stays in task 2 for 45 minutes; the second token stays in task 3 for 30 minutes. 
				The second token arrives at the none event first, where it is consumed. After 15 more minutes, the first token arrives at the upper none event, where it is consumed too. 
				Since no more tokens are available, the process instance finishes after 55 minutes. 
			</p>
			<div id="terminate_without" style="position:relative">
				<script>
					bpmn("tutorial/terminate_without", "terminate_without");
				</script>
			</div>			
			<p>
				So far, so good, but what happens if we already know that, after having completed task 3, task 2 has become redundant? This is a frequent situation with parallel task executions related to content. 
				In such cases, we can apply the pattern shown in here: 
			</p>
			<div class="label label-warning">Hover over orange symbols for explanation</div>
			<div id="terminate" style="position:relative">
				<script>
					bpmn("tutorial/terminate", "terminate");
				</script>
				<div class="tutPop" id="terminate-sid-A14E9B4C-CDAE-45C0-A878-082E588C6941" rel="popover" title="Terminate Event" data-content="
					We use the terminate event to make sure that ALL available tokens are consumed immediately. 
				That leads to the termination of the process instance, consequently, you can use the terminate event as an end event only.
				">
				</div>				
			</div>			
			<h2>Link Events</h2>
			<p>	
				The link event is a special case. It has no significance related to content, but it facilitates the diagram-creation process. 
				As shown below, you can draw two associated links as an alternative to a sequence flow. Here, "associated" means there is a throwing link event as the "exit point," 
				and a catching link event as the "entrance point," and the two events are marked as a pair - in our example by the designation "A." 
			</p>
			<div id="link" style="position:relative">
				<script>
					bpmn("tutorial/link", "link");
				</script>
			</div>			
			<p>
				Link events can be very useful if:
				<ul>
					<li>You have to distribute a process diagram across several pages. Links orient the reader from one page to the next.</li>
					<li>You draw comprehensive process diagrams with many sequence flows. Links help avoid what otherwise might look like a "spaghetti" diagram.</li>
				</ul>
				Link events can be used as intermediate events only.
			</p>
			<h2>Compensation Events</h2>
			<p>
				We execute tasks in our processes that sometimes have to be canceled later under certain circumstances. 
			</p>
			<p>
				Typical examples are:
				<ul>
					<li>Booking a train or airline ticket</li>
					<li>Reserving a rental car</li>
					<li>Charging a credit card</li>
					<li>Commissioning a service provider</li>
				</ul>
				Below, we see this process: On Friday at 1 p.m. we agree with our partner either to go to the theater or to spend the evening with friends.
				In both cases, we have to do something binding, either to reserve the theater tickets or make the arrangements with our friends. 
				When evening arrives, perhaps we no longer feel like going out at all. We then have to cancel the arrangements we made with the theater or our friends before we can collapse in front of the TV in peace:
			</p>
			<div  style="width:100%; overflow:auto;">
				<div id="compensation_without" style="position:relative">
					<script>
						bpmn("tutorial/compensation_without", "compensation_without");
					</script>
				</div>			
			</div>
			<p>
				We can represent the latter part of the model more compactly with a compensation event, as shown in here: 
			</p>
			<div class="label label-warning">Hover over orange symbols for explanation</div>
			<div id="compensation" style="position:relative">
				<script>
					bpmn("tutorial/compensation", "compensation");
				</script>
				<div class="tutPop" id="compensation-sid-6CB628A9-C00C-44F4-A2B0-9B1749277A09" rel="popover" title="Compensation Event (throw)" data-content="
					If we don't feel like going out, we have to cancel all our arrangements; we don't have to check which ones to cancel. 							">
				</div>				
			</div>			
			<p>
				There are special rules for handling compensations:
				<ul>
					<li>Throwing compensations refer to their own processes, so the event is effective within the pool. This shows how this event type differs from a throwing message event.</li>
					<li>Other attached events can take effect only while the activities to which they are attached remain active. 
					In contrast, an attached compensation takes effect only if the process triggers a compensation <b>and</b> the activity to which the compensation is attached successfully completed.</li>
					<li>Attached compensation events connect to compensation tasks through associations, and <b>not</b> through sequence flows, which would otherwise be common usage. 
					BPMN thus emphasizes that compensations are beyond the regular process sequence; executing one is an exception.</li>
					<li>The obligatory compensation task is a special task type that we explain with other task types in TODO</li>
				</ul>
			</p>
			<div class="accordion" id="accComp">
			  <div class="accordion-group">
				<div class="accordion-heading">
				  <a class="accordion-toggle" data-toggle="collapse" data-parent="#accComp" href="#CompcollapseOne">
					<i class="icon-thumbs-up"></i> Best Practice: Using Compensation Events
				  </a>
				</div>
				<div id="CompcollapseOne" class="accordion-body collapse">
				  <div class="accordion-inner">
					This example may be too simple to illustrate how much work this construct can save you. If you think of the complex business processes that frequently require compensations, 
					however, you'll see how much leaner your models can be. You'll also be quick to spot the circumstances that demand compensations.  We use compensation events only 
					occasionally to describe complex processes. 
				  </div>
				</div>
			  </div>
			</div>
			<h2>Multiple Events</h2>
			<p>
				We can use the multiple event to summarize several events with a single symbol. The diagram below applies the multiple event to our pizza scenario. 
				In the example, we try a new pizza after having seen it on TV or after a friend recommended it. After eating it, we will rate the pizza on Pizzatest.de and in turn inform our friend if 
				we also recommend this pizza. 
			</p>
			<div class="label label-warning">Hover over orange symbols for explanation</div>
			<div id="multiple" style="position:relative">
				<script>
					bpmn("tutorial/multiple", "multiple");
				</script>
				<div class="tutPop" id="multiple-sid-0FC67A07-E457-4C69-A06C-8FA465A0D173" rel="popover" title="Multiple Event (catch)" data-content="
					If we model the multiple event as a catching event, ONLY ONE of the summarized events has to occur to start or continue the process or to cancel the task.">
				</div>				
				<div class="tutPop" id="multiple-sid-92DF9B54-1E65-4973-ABCE-52093BFB571D" rel="popover" title="Multiple Event (throw)" data-content="
					If we model a multiple event as a throwing event, it means that ALL of the summarized events are triggered.">
				</div>				
			</div>			
			<div class="accordion" id="accMultiple">
			  <div class="accordion-group">
				<div class="accordion-heading">
				  <a class="accordion-toggle" data-toggle="collapse" data-parent="#accMultiple" href="#MultiplecollapseOne">
					<i class="icon-thumbs-up"></i> Best Practice: Avoiding Multiple Events
				  </a>
				</div>
				<div id="MultiplecollapseOne" class="accordion-body collapse">
				  <div class="accordion-inner">
					You have to decide if multiple events serve your purposes. We concede their benefit in rough functional process descriptions, but they cease to be as useful in the more advanced 
					technical-implementation phase. You can't afford to leave relevant details hiding in the descriptive text. We don't find the multiple event to be intuitive, nor is it helpful on a functional level. 
					It may make your diagrams larger to model all events separately, but the resulting diagrams will be both more comprehensive and more comprehensible. 
					The bottom line is that we have never used this symbol in practice, nor have we seen anybody else doing so. 
					<p>
						The model in here describes the same process, but the events are fully modeled:
						<div id="multiple_without" style="position:relative">
							<script>
								bpmn("tutorial/multiple_without", "multiple_without");
							</script>
						</div>			
					</p>
				  </div>
				</div>
			  </div>
			</div>
			
			<h2>Parallel Events</h2>
			<p>
				The parallel event was added in BPMN 2.0 to supplement the multiple event. While a catching multiple event has XOR semantics - it occurs as soon as 
				<b>one</b> of its contained events occurs - the parallel event uses AND semantics. It doesn't occur until <b>all</b> of its contained events occur. Because the throwing multiple event 
				already implies AND semantics, the specification defines parallel events as catching events only. 			
			</p>
			
			<h2>Escalation Events</h2>
			<p>
				The BPMN 2.0 specification added the escalation event. Mainly, it shows communication between parent and sub-processes. We discuss it in here TODO with the help of an example.	
			</p>
			
			<h2>Cancel Events</h2>
			<p>
				You can use the cancel event only in the context of the transactions we discuss in TODO. That section also has examples of applying this event type. 
			</p>
			
			<h2>Event-based Gateway</h2>
			<p>
				We learned about the exclusive data-based (XOR) gateway option in TODO as a way to use different paths with regard to the data being processed. 
				Users of other process notations recognize this type of branching, but BPMN gives us another way to design process paths: 
				the event-based gateway - event gateway, for short. This gateway does not route based on data, but rather by which event takes place next. To understand the 
				benefit, consider the process shown below: We order pizza and wait for it to be delivered. We can eat only after we receive the pizza, but what if the pizza doesn't arrive after 60 minutes? 
				We'll make an anxious phone call, that's what! We can model this with the event gateway: 
			</p>
			<div class="label label-warning">Hover over orange symbols for explanation</div>
			<div id="event-based" style="position:relative">
				<script>
					bpmn("tutorial/event-based", "event-based");
				</script>
				<div class="tutPop" id="event-based-sid-86AEEAF2-E1FF-4EF3-B34E-7ADD4D914B47" rel="popover" title="Event-based Gateway" data-content="
					Now, in contrast to the data-based XOR split, the token waits at the event gateway for one of the subsequent events to occur. Once any one event occurs, the token takes the respective path. 
					If other events then take place, they are ignored. This is XOR semantics. 
					">
				</div>				
			</div>			
			<p>
				As you can see here, not all intermediate events combine with the event gateway. You can, however, combine it with the receive task, which we discuss in TODO.
			</p>
			<div id="event-based-events" style="position:relative">
				<script>
					bpmn("tutorial/event-based-events", "event-based-events");
				</script>
			</div>			
		</section>
		<section id="subprocessesSect">
			<div class="page-header" >
				<h1>Subprocesses</h1>
			</div>
			<h2>Encapsulate complexity</h2>
			<p>
				The examples in this tutorial either deal with simple processes, or they diagram complex processes superficially so that the models fit on one page. 
				When modeling your process landscape, you don't have this luxury. You have to rough out your processes so that you can get the general ideas in place and recognize correlations. 
				Then you have to develop a detailed description, so that you can analyze exactly where the weak points are or how you'll have to execute the process in practice. 
				The possible top-down refinements or bottom-up aggregations mark the difference between true process models and banal flow charts, between sophisticated BPM software products and mere drawing programs. 
			</p>
			<p>
				BPMN provides us with the subprocess to help with the expanding/collapsing view. A subprocess describes a detailed sequence, but it takes no more space in the diagram of the parent process 
				than does a task. Both tasks and subprocesses are part of the activities class and are therefore represented as rectangles with rounded corners. The only difference is the plus sign, 
				indicating a stored detailed sequence for the subprocess:
			</p>
			<div id="subprocess" style="position:relative">
				<script>
					bpmn("tutorial/subprocess", "subprocess");
				</script>
			</div>
			<p>
				What good is that to us? That depends most on how your BPMN tool supports the following options for connecting subprocesses with their parent processes: 
				<ul>
					<li><b>Representation in a separate process diagram</b>: The subprocess symbol links to a separate diagram. If your BPMN tool displays the process model in a web browser, 
					for instance, clicking on the symbol would open a new page to display the detail diagram.</li>
					<li><b>Expanding in the process diagram of the parent process</b>: The activity with the plus sign is called a collapsed subprocess. The plus sign suggests that you could click on it and make 
					the subprocess expand. The BPMN specification provides for this option, though not all tool suppliers implement it. The diagram below shows how the subprocess was directly expanded in the diagram of 
					the parent process. A tool supporting this function enables you to expand and collapse the subprocess directly in the diagram, respectively, to show or hide details.</li>
				</ul>
			</p>
			<div id="subprocess_expanded" style="position:relative">
				<script>
					bpmn("tutorial/subprocess_expanded", "subprocess_expanded");
				</script>
			</div>
			<p>
				Direct expansion may seem appealing, but often it is not useful in practice. Expanding the subprocess requires that all the adjacent symbols in the diagram shift to make room. 
				This can result in sluggish performance with a complex diagram, and it can be visually nasty. The most important thing is that your tool provides for linking and that you can usefully navigate 
				through the diagrams. In other words, it supports the first option above. Yes, it can be helpful to have your subprocess modeled and expandable directly from the parent process. 
				That means process segments remain localized, and you can attach events too. This is, however, the less important option.			
			</p>
			<p>
				The sequence flow of the parent process ends in both cases at the left edge of the subprocess. The next sequence flow starts at the right edge. This means that sequence flows are not allowed to exceed the 
				boundaries of the subprocess, which not every beginner knows, and which becomes a problem when a subprocess expands. Visualize a token that behaves as follows:
				<ul>
					<li>The parent process starts, and a token is born.</li>
					<li>The token runs through the task and arrives at the subprocess, which causes the parent process to create an instance of the subprocess.</li>
					<li>Within the subprocess, a separate token is born which runs through the subprocess from the start to the end event, but the token of the parent process waits until the subprocess completes.</li>
					<li>When the subprocess token arrives at the end event, it is consumed, which completes the subprocess. Now the token of the parent process moves to its own end event. </li>
				</ul>
			</p>
			<p>
				The encapsulation in subprocesses that we're describing isn't restricted to two levels. You could just as easily have a parent process as a subprocess, or you could model further subprocesses on the 
				level of a defined subprocess. How many levels you use and the level of detail you apply to model them is up to you. BPMN doesn't specify this, and there can be no cross-company or cross-scenario cookbook 
				to define levels. Participants in our BPMN workshops don't like this, but there's no point in hiding the fact nor attempting to explain it away. In the following chapters, we work often with 
				subprocesses in explaining our best practices, but the truth is the number of refinement levels and their respective levels of detail is always situational. It depends on the organization, the roles 
				of the project participants, and the goals for the process you're modeling. 			
			</p>
		</section>
		</div>
		</div>
</div>
<style>
 .popover {z-index:100 !important;}
</style>
			<script>
						$('.tutPop').popover({
							"trigger": "hover",
							"placement": "bottom"
						})
					</script>
