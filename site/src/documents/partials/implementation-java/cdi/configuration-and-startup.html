<section id="cdi-bootstrap">

<div class="page-header">
      <h1>Engine Startup in CDI</h1>
</div>
  
<div class="row-fluid">
  <div class="span9">
        
The camunda-engine-cdi modules leverages both the configurability of the camunda engine and the extensibility of CDI. The most prominent features  are:
<ul>
    <li>Support for @BusinessProcessScoped beans (CDI beans the lifecycle of which is bound to a process instance),</li>
    <li>A custom El-Resolver for resolving CDI beans (including EJBs) from the process,</li>
    <li>Declarative control over a process instance using annotations,</li>
    <li>Process Engine is hooked-up to the CDI event bus,</li>
    <li>Works with both Java EE and Java SE, works with Spring,</li>
    <li>Support for unit testing.</li>
</ul>

In order to include the module in a maven project, we add the following maven dependency:

<div class="app-source" app-source-no-tabs="cdi1"></div>
<script type="text/xml" id="cdi1">   
<dependency>
        <groupId>org.camunda.bpm</groupId>
        <artifactId>camunda-engine-cdi</artifactId>
        <version>7.x</version>
</dependency>
</script>

Replace 'x' with your camunda BPM version.


    </div>
    <div class="span3">
      <h3>On this page</h3>
      <ul>            
          <li>Engine Startup in CDI</li>
          <li>Looking up a Process Engine</li>
          <li>Configuring the Process Engine</li>
      </ul>
    </div>
</div>


  


<h2>Looking up a Process Engine</h2>
<p>
The cdi extension needs to get access to a ProcessEngine. To achieve this, an implementation of the interface org.camunda.bpm.engine.cdi.spi.ProcessEngineLookup is looked up at runtime. The cdi module ships with a default implementation named org.camunda.bpm.engine.cdi.impl.LocalProcessEngineLookup, which uses the ProcessEngines-Utility class for looking up the ProcessEngine. In the default configuration ProcessEngines#NAME_DEFAULT is used to lookup the ProcessEngine. This class might be subclassed to set a custom name. NOTE: needs an activiti.cfg.xml configuration on the classpath.
</p>

<p>
camunda-engine-cdi uses a java.util.ServiceLoader SPI for resolving an instance of org.camunda.bpm.engine.cdi.spi.ProcessEngineLookup. In order to provide a custom implementation of the interface, we need to add a plain text file named META-INF/services/org.camunda.bpm.engine.cdi.spi.ProcessEngineLookup to our deployment, in which we specify the fully qualified classname of the implementation.
</p>

<p>
<strong>Note:</strong> If you do not provide a custom org.camunda.bpm.engine.cdi.spi.ProcessEngineLookup implementation, the engine will use the default LocalProcessEngineLookup implementation. In that case, all you need to do is providing a activiti.cfg.xml file on the classpath (see next section).
</p>






<h2>Configuring the Process Engine</h2>

<p>
Configuration depends on the selected ProcessEngineLookup-Strategy (cf. previous section). Here, we focus on the configuration options available in combination with the LocalProcessEngineLookup, which requires us to provide a Spring activiti.cfg.xml file on the classpath.
</p>

<p>
camunda offers different ProcessEngineConfiguration implementations mostly dependent on the underlying transaction management strategy. The camunda-engine-cdi module is not concerned with transactions, which means that potentially any transaction management strategy can be used (even the Spring transaction abstraction). As a convenience, the cdi-module provides two custom ProcessEngineConfiguration implementations:
</p>
<ul>
    <li>org.camunda.bpm.engine.cdi.CdiJtaProcessEngineConfiguration: a subclass of the JtaProcessEngineConfiguration, can be used if JTA-managed transactions should be used for the engine.</li>
    <li>org.camunda.bpm.engine.cdi.CdiStandaloneProcessEngineConfiguration: a subclass of the StandaloneProcessEngineConfiguration, can be used if plain JDBC transactions should be used for engine.</lI>
</ul>

<p>
  The following is an example activiti.cfg.xml file for JBoss 7:
</p>


<div class="app-source" app-source-no-tabs="cdi2"></div>
<script type="text/xml" id="cdi2">   
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">

        <!-- lookup the JTA-Transaction manager -->
        <bean id="transactionManager" class="org.springframework.jndi.JndiObjectFactoryBean">
                <property name="jndiName" value="java:jboss/TransactionManager"></property>
                <property name="resourceRef" value="true" />
        </bean>

        <!-- process engine configuration -->
        <bean id="processEngineConfiguration"
                class="org.camunda.bpm.engine.cdi.CdiJtaProcessEngineConfiguration">
                <!-- lookup the default Jboss datasource -->
                <property name="dataSourceJndiName" value="java:jboss/datasources/ExampleDS" />
                <property name="databaseType" value="h2" />
                <property name="transactionManager" ref="transactionManager" />
                <!-- using externally managed transactions -->
                <property name="transactionsExternallyManaged" value="true" />
                <property name="databaseSchemaUpdate" value="true" />
        </bean>
</beans>
</script>

And this is how it would look like for Glassfish 3.1.1 (assuming a datasource named jdbc/camunda is properly configured):

<div class="app-source" app-source-no-tabs="cdi3"></div>
<script type="text/xml" id="cdi3">   
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">

        <!-- lookup the JTA-Transaction manager -->
        <bean id="transactionManager" class="org.springframework.jndi.JndiObjectFactoryBean">
                <property name="jndiName" value="java:appserver/TransactionManager"></property>
                <property name="resourceRef" value="true" />
        </bean>

        <!-- process engine configuration -->
        <bean id="processEngineConfiguration"
                class="org.camunda.bpm.engine.cdi.CdiJtaProcessEngineConfiguration">
                <property name="dataSourceJndiName" value="jdbc/camunda" />
                <property name="transactionManager" ref="transactionManager" />
                <!-- using externally managed transactions -->
                <property name="transactionsExternallyManaged" value="true" />
                <property name="databaseSchemaUpdate" value="true" />
        </bean>
</beans>
</script>
        
Note that the above configuration requires the "spring-context" module:

<div class="app-source" app-source-no-tabs="cdi4"></div>
<script type="text/xml" id="cdi4">   
<dependency>
        <groupId>org.springframework</groupId>
        <artifactId>spring-context</artifactId>
        <version>3.0.3.RELEASE</version>
</dependency>
</script>

<p>
The configuration in a Java SE environment looks exactly like the examples provided in section Creating a ProcessEngine, substitute "CdiStandaloneProcessEngineConfiguration" for "StandaloneProcessEngineConfiguration".
</p>
	
</section>